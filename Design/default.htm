<html>

    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>Atlanta Lending Library - Design</title>
    </head>

    <body>

        <div class="content">

            <h1>Atlanta Lending Library - Design</h1>
            
            <h2>Introduction</h2>
            
            <p>
                The Atlanta project started life as an example of how to use NHibernate
                and Spring.Net.  It has evolved into a sample application of how to combine
                best practice techniques and best of breed technologies to create an application.
            </p>
            <p>
                The project currently uses the following technologies:
            </p>
            <ul>
                <li>NAnt;</li>
                <li>NUnit;</li>
                <li>NHibernate;</li>
                <li>Spring.Net;</li>
                <li>Silverlight;</li>
                <li>NCover;</li>
                <li>Firebird (RDBMS).</li>
            </ul>
            
            <p>
                This remaining sections of this document describe the Development Methodology,
                Architecture (patterns and implementation),
                and functional design of the Atlanta Lending Library.
            </p>

            <h2>Development Methodology</h2>
            <p>
                The development on Atlanta does not subscribe to a single methodology (e.g., XP, SCRUM)
                but instead borrows techniques from methodologies in the Agile/Lean arena.
            </p>
            <p>
                In addition, the nature of development on an example project doesn't lend itself
                to the sort of pressures and deadlines that demonstrate the advantages of Agile
                practices in the field.
                As such, the development of Atlanta sticks to the core principals of:
            </p>
            <ul>
                <li>Test Driven Development (TDD);</li>
                <li>Continuous Integration (CI);</li>
                <li>Collective Code Ownership;</li>
                <li>Aggressive Refactoring.</li>
            </ul>
            <p>
                We have a suite of tests using NUnit, an automated build using NAnt,
                built in test-coverage checked in the build using NCover, and we endeavour
                to ensure that every Subversion check-in results in a working end-to-end build.
            </p>
            <p>
                In reality we normally subscribe to any of a range of techniques when creating software,
                including:
            </p>
            <ul>
                <li>Iterative and Incremental Development (IID);
                    <ul><li>with preference to shorter iterations - e.g., 1 week</li></ul></li>
                <li>Time Boxing;</li>
                <li>Requirements Freeze;</li>
                <li>Sustainable Development;</li>
                <li>Whole Team Together;</li>
                <li>Pair Programming;</li>
                <li>e.t.c., ...</li>
            </ul>

            <h2>Architecture</h2>
            
            <p>
                The architecture of Atlanta is described in two parts:
            </p>
            <ul>
                <li>
                    Part 1 describes the architecture using Design Patterns.
                    Note that these patterns describe the architecture of the system
                    in a technology agnostic fashion - they could just as easily be describing
                    a system implemented in Java;
                </li>
                <li>
                    Part 2 desribes the (.NET specific) technologies used to implement the patterns discussed in Part 1.
                </li>
            </ul>

            <h3>Part 1 - Architectural Patterns</h3>
            
            <p>
                The Atlanta architecture is a
                Layered Application with three principal layers:
            </p>
            <ul>
                <li>Business Logic;</li>
                <li>Services;</li>
                <li>Presentation.</li>
            </ul>
            
            <h4>Business Logic Layer</h4>
            <p>
                The core business logic is implemented using a
                <a target="_blank" href="http://martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a>.
            </p>
            <p>
                The model is persisted in a relational database using a
                <a target="_blank" href="http://martinfowler.com/eaaCatalog/dataMapper.html">Data Mapper</a>.
                <a target="_blank" href="http://martinfowler.com/eaaCatalog/lazyLoad.html">Lazy Load</a>
                allows the model to traverse associations without explicit data
                access code, while an
                <a target="_blank" href="http://martinfowler.com/eaaCatalog/identityMap.html">Identity Map</a>
                maintains reference equality throughout the domain.
                Changes to the model are tracked (and ultimately persisted) using a
                <a target="_blank" href="http://martinfowler.com/eaaCatalog/unitOfWork.html">Unit of Work</a>.
            </p>
            <p>
                Data access is hidden behind a
                <a target="_blank" href="http://martinfowler.com/eaaCatalog/repository.html">Repository</a>,
                and a
                <a target="_blank" href="http://martinfowler.com/eaaCatalog/queryObject.html">Query Object</a>
                is used to allow interrogation of the database in an object-oriented fashion
                while keeping the model free of the internal mechanism.
            </p>

            <h4>Services Layer</h4>
            <p>
                A <a target="_blank" href="http://martinfowler.com/eaaCatalog/serviceLayer.html">Service Layer</a>
                is employed as an application boundary where aspects can be applied
                consistently across a range of methods (AOP).
                While the Service Layer is aware of persistence mechanisms, it is kept
                free of business logic and merely acts as an entry point into the
                Domain Model.
            </p>
            <p>
                A <a target="_blank" href="http://martinfowler.com/eaaCatalog/remoteFacade.html">Remote Facade</a>
                exposes the coarse grained interface across the wire.
            </p>

            <h4>Presentation Layer</h4>
            <p>
                The presentation logic uses a variation on
                Model View Controller,
                specifically
                <a target="_blank" href="http://martinfowler.com/eaaDev/PassiveScreen.html">Passive View</a>.
                The controller talks to the model using the Remote Facade exposed
                from the services layer, and is responsible for controlling the
                state and input of the widgets from the view.
            </p>
            
            <h3>Part 2 - Pattern Implementations</h3>

            <h2>Analysis Model</h2>

            <h2>Use Cases</h2>

        </div>

    </body>

</html>

